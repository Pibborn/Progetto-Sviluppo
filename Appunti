gli use-case devono rispecchiare i termini utilizzati nel glossario: se ho dei sinonimi li cambio in uno dei due documenti

le 'caselle' che definiscono use-case (componi messaggio, cifra messaggio...) possono essere definite a loro volta in use-case piu'
dettagliati, ma non e' obbligatorio

class diagram: se non e' dettagliato allora e' meglio non inserire cose che dipendono dall'implementazione del sistema
               se stiamo gia' facendo delle scelte progettuali, e' troppo nel dettaglio per un diagramma non-dettagliato
               descrittivo, non vincolante
               non deve dipendere dal sistema

agente studente: rappresenta quello che possono fare tutti

come scegliere il 10% dei casi di uso da dettagliare? devono essere rappresentativi dei casi d'uso del sistema, che quindi ne coinvolgano
gli elementi chiave. 
se un caso d'uso è molto semplice, è preferibile una buona descrizione testuale ad un diagramma elementare. 

ci sono due sistemi per fare i casi d'uso dettagliati: la prof. ci fa vedere entrambi, almeno all'inizio. siamo liberi di usare
quello che preferiamo.

i casi d'uso dettagliati sono a grandi linee un elenco di cose che il sistema deve offrire all'utente,
e per ognuno di questi quali sono i casi d'uso utili allo scopo.

il primo stile è completamente testuale. indico alternative facendo una tabella separata che fa riferimento al punto specifico della tabella
"principale" che modella il caso d'uso. posso anche riassumere le azioni del sistema con degli "pseudonomi di metodo", che non è obbligatorio 
rispettare a livello di implementazione. la debolezza di questo stile è che si perde uno sguardo d'insieme e del flusso che effettivamente
ha lo use case.

lo schema che stiamo facendo (creasistemacifratura) è un sequence/activity (più activity)

suggerimento: si prevedano dei casi d'uso a parte per i tool di supporto. questo perchè tali strumenti potrebbero essere sviluppati ulteriorm.
in seguito (non lo faremo). in generale la modularizzazione del sw può già cominciare dalla fase di progettazione. inoltre non lavoreremo su
tutti i casi d'uso, quindi dividerli e modulizzarli può tornare utile nel momento in cui sceglieremo quali sviluppare (concordandoli con i prof)

non vogliamo creare un sistema intelligente per risolvere problemi di crittografia, solamente un sistema per aiutare gli analisti che li risolvono!
una persona che fa crittoanalisi tipicamente ha davanti il testo cifrato che vuole decifrare, e di solito si suggerisce di inserire sotto le parole
cifrate il testo in chiaro, o quantomeno i pezzi che sinora è riuscito a decifrare.

esempio:
wrhgw euhuh
c p i ron a

voglio anche mantenere un albero delle ipotesi, a cui però non devo necessariamente ad ogni passo aggiungere ipotesi, ma potrei volere anche magari
poter riconsiderare, modificare e rimuovere alcune di esse. inoltre ad ogni passo può opzionalmente richiedere delle analisi statistiche.
questi i passi che l'analista compirà:

1. pensare/analizzare (eventualmente con strumenti di supporto statistici)
2. aggiornare l'ipotesi, il che modifica il mio albero. questo è simile a fare una mossa in un gioco. oppure faccio una UNDO.

si noti che una sola ipotesi può modificare più di un'assegnazione lettera-lettera. l'albero delle ipotesi è gestibile come uno stack. se per caso 
l'analista giunge ad un'ipotesi che aveva già formulato in precedenza, potrei volerlo avvisare di tale fatto: da qui l'esigenza di un albero delle ipotesi.
non è detto che avere effettivamente una visualizzazione grafica di tale albero sia necessario, ma è un'opzione da considerare. magari posso tenergli uno storico
delle ultime 2-3 cose che ha fatto. è anche utile che venga data all'analista l'opzione di poter immettere nel sistema le sue motivazioni per aver riconsiderato
o scartato un'ipotesi.
